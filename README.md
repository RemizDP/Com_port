# Com_port
Проект предназначен для настройки и отладки COM-порта, обмена информацией (байт) по COM-порту между компьютером на ОС LINUX с некоторым устройством (модем или др.).
В большей степени в качестве источников использовались StackOverflow, Habr и OpenNet (источники указаны в конце).

Был реализован класс TApcSerialPort, содержащий следующие методы:
	int get_FH(); -- Возвращает файловый дескриптор порта

    int file_open(const std::string astrPortPathName); -- Открытие файла на чтение и запись. Терминальное устройство по этому пути не станет терминальным устройством управления процесса, работа в режиме синхронного ввода/вывода.т.е. пока данные не будут физически записаны, write блокирует вызывающий процесс с помощью стандартной функции языка С; 

    int file_close(); -- Закрытие порта с помощью стандартной функции языка С;

    int SetDefaultSettings(uint32_t adwBaudRate); -- Установка настроек порта (для неканонического режима) 8N1 (данные передаются побайтно, нет бита четности, 1 стоповый бит)по умолчанию.  
    	Setup: 
    	установка флагов (CLOCAL -- флаг игнорирования управления линиями с помощью модема
    				CREAD -- флаг включения приема)
    	сброс флагов (CSTOPB -- установка только одного стопового бита 
    				CRTSCTS -- отключение аппаратного управления потоком)

    	с помощью ф-ции cmakeraw(struct termios *termios_p) осуществляется:
    	сброс флагов (IGNBRK -- флаг игнорирования режим BREAK (Ctrl+BREAK), 
                  	BRKINT -- флаг сброса очередей, 
                  	PARMRK -- флаг отслеживания ошибки, 
                  	ISTRIP -- флаг удаления 8-го бита, 
                  	INLCR -- флаг преобразовывания NL в CR при вводе
                  	IGNCR -- флаг игнорирования перевода каретки,
                  	ICRNL -- флаг преобразовывания перевода каретки в конец строки при вводе,
                  	IXON -- флаг запуска управления потоком данных XON/XOFF при выводе) 
    	сброс флагов (ECHO -- флаг ECHO,
                  	ECHONL -- флаг ECHO новой строки,
                  	ICANON -- флаг канонического режима (линии используют специальные символы:
                  	EOF, EOL, EOL2, ERASE, KILL, LNEXT, REPRINT, STATUS и WERASE, а также строчную буферизацию) 
                  	ISIG -- флаг генерации сигналов при вводе сиволов из INTR, QUIT, SUSP или DSUSP
                  	IEXTEN -- флаг включения режима ввода по умолчанию (как и ICANON 
                  	должен быть включен для обработки специальных символов EOL2, LNEXT, 
                  	REPRINT, WERASE, а также для того, чтобы работал флаг IUCLC.))
    	сброс       OPOST -- флага включени режима вывода по умолчанию (если OPOST бит не 
    				установлен, все остальные флаги игнорируются, а символы выводятся дословно).;
    	сброс флагов (CSIZE -- флага маски размера символов,
                  	PARENB -- флага бита четности)
    	установка флага CS8 -- 8-bit символы (установка маски размера).

    	Замечание. Значения флагов по умолчанию устанавливаются следующим образом:
    			значения c_iflag по умолчанию: (BRKINT|ICRNL|IMAXBEL)
    			значения c_lflag по умолчанию: (ISIG|ICANON|ECHO|IEXTEN|ECHOE|ECHOKE|ECHOCTL).
    			значения c_oflag по умолчанию: (OPOST|ONLCR|ONOEOT).
    	Также устанавливаются значения  c_cc[VMIN] -- минимальное кол-во символов для передачи
    			за раз
    			c_cc[VTIME] -- время ожидания (задержка) в децисекундах
    			BaudRate -- количество передаваемых байт в секунду.
    Затем вышеуказанные настройки применяются с помощью функции tcsetattr(int fd, int optional_actions, struct termios *termios_p);

    int write(uint8_t* apBuf, size_t astSize, uint32_t adwTimeout, size_t& astWritten) -- запись в порт. В параметрах находятся входной буфер информации, количество символов, которые надо записать, таймаут порта, количество символов, успешно записанных (отправленных на запись устройству по порту). Создается структура для взаимодействий с событием pollfd, функция poll ожидает наступления какого-либо события (в нашем случае событие pollout -- отправка данных). Когда событие наступило, с помощью стандартной функции write языка С записываем данные;

    int read(uint8_t* apBuf, size_t astSize, uint32_t adwTimeout, size_t& astRlen)-- Чтение из порта. В параметрах находятся выходной буфер информации, количество символов, которые надо прочесть, таймаут порта, количество символов, успешно прочитанных (отправленных на запись устройству по порту). Создается структура для взаимодействий с событием pollfd, функция poll ожидает наступления какого-либо события (в нашем случае событие pollout -- отправка данных). Когда событие наступило, с помощью стандартной функции read языка С читаем данные. Ситуация, когда прочитано меньше символов, чем было указано в параметре, ошибочной не является, количество прочитанных символов зависит от логики работы подключенного устройства и количества памяти в ней;