# Com_port
Проект предназначен для настройки и отладки COM-порта, обмена информацией (байт) по COM-порту между компьютером на ОС LINUX с некоторым устройством (модем или др.).
В большей степени в качестве источников использовались 
StackOverflow (https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c), 
Habr(https://habr.com/ru/companies/ruvds/articles/578432/) и OpenNet 

Раньше по последовательным портам к машинам на UNIX подключались терминалы, поэтому у последовательных портов предусмотрены функции терминала, которые в нашем случае следует отключить (реализовано в методах file_open и configure). Также написал перегрузку метода configure, с помощью которой можно настроить разные режимы чтения с помощью параметров MIN и TIME http://unixwiz.net/techtips/termios-vmin-vtime.html
Эти параметры влияют тогда, когда внешнее устройство еще не подготовило символы для чтения, а попытка чтения уже произошла. 

Запись в порт и чтение из порта, реализованы с использованием структуры pollfd. Функция poll использует эту структуру, ожидает наступление событий (в нашем случае POLLIN -- символы готовы для прочтения с порта; и POLLOUT символы готовы для записи в порт)

Так же сделаны функции чтения и записи со "внешними" таймаутом и размером буфера. Если истекает внешний таймаут или количество символов достигает внешнего размера буфера, то чтение/запись прекращается.

Сделал move конструктор и оператор присваивания (во избежание записи в уже закрытый порт или чтения из уже закрытого порта)

Реализованы 3 группы тестов:
1) На компьютере нет последовательных портов: попытка открыть порт с именем "Any_string_name"
2) Последовательный порт есть, но к нему не подключено внешнее устройство: Проверка существования порта по его пути-имени, поочередное выставление на порте разных скоростей передачи (от 1200 бод до 115200 бод), вывод установленной скорости каждый раз после установки.
3) Последовательный порт есть и к нему подключено некоторое устройство: запись в порт 100 байт (входной массив заполнен нулями) и чтение 100 байт (можно настроить в методах cycleTest onceTest) из порта в различных режимах с выводом прочитанного и временем чтения/записи (и частного и внешнего) на экран. Предусмотрены 2 режима чтения/записи: с внешним таймаутом и размером и без, в каждом из режимов MIN и TIME ранжируются значениями {0, 1, 5, 10} (можно настроить в методах cycleTest onceTest), каждый тест для чистоты эксперимента проводится по 5 раз (можно настроить в методах cycleTest onceTest), итого получается 2*4*4*5=160 тестов при разных настройках.;